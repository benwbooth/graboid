{% extends "base.html" %}

{% block title %}Configuration - Graboid{% endblock %}

{% block content %}
<h1>Configuration</h1>

{% if request.query_params.get('saved') %}
<div class="alert success">
    Configuration saved successfully.
</div>
{% endif %}

<form method="post" action="/config">
    <div class="grid-2">
        <div class="card">
            <h2>Torrent Client</h2>

            <label for="torrent_client">Client</label>
            <select name="torrent_client" id="torrent_client">
                <option value="auto" {% if config.get('torrent_client') == 'auto' %}selected{% endif %}>Auto (fallback chain)</option>
                <option value="embedded" {% if config.get('torrent_client', 'embedded') == 'embedded' %}selected{% endif %}>Embedded (librqbit feature)</option>
                <option value="qbittorrent" {% if config.get('torrent_client') == 'qbittorrent' %}selected{% endif %}>qBittorrent</option>
                <option value="transmission" {% if config.get('torrent_client') == 'transmission' %}selected{% endif %}>Transmission</option>
                <option value="deluge" {% if config.get('torrent_client') == 'deluge' %}selected{% endif %}>Deluge</option>
                <option value="rtorrent" {% if config.get('torrent_client') == 'rtorrent' %}selected{% endif %}>rTorrent</option>
                <option value="aria2" {% if config.get('torrent_client') == 'aria2' %}selected{% endif %}>aria2</option>
            </select>

            <h3 style="margin: 1.5rem 0 1rem; font-size: 1rem;">qBittorrent Settings</h3>

            <label for="qbittorrent_host">Host</label>
            <input type="text" name="qbittorrent_host" id="qbittorrent_host"
                   value="{{ config.get('qbittorrent_host', 'localhost') }}">

            <label for="qbittorrent_port">Port</label>
            <input type="number" name="qbittorrent_port" id="qbittorrent_port"
                   value="{{ config.get('qbittorrent_port', 8080) }}">

            <label for="qbittorrent_username">Username</label>
            <input type="text" name="qbittorrent_username" id="qbittorrent_username"
                   value="{{ config.get('qbittorrent_username', 'admin') }}">

            <label for="qbittorrent_password">Password</label>
            <input type="password" name="qbittorrent_password" id="qbittorrent_password"
                   value="{{ config.get('qbittorrent_password', 'adminadmin') }}">

            <h3 style="margin: 1.5rem 0 1rem; font-size: 1rem;">Transmission Settings</h3>

            <label for="transmission_host">Host</label>
            <input type="text" name="transmission_host" id="transmission_host"
                   value="{{ config.get('transmission_host', 'localhost') }}">

            <label for="transmission_port">Port</label>
            <input type="number" name="transmission_port" id="transmission_port"
                   value="{{ config.get('transmission_port', 9091) }}">

            <label for="transmission_username">Username</label>
            <input type="text" name="transmission_username" id="transmission_username"
                   value="{{ config.get('transmission_username', '') }}">

            <label for="transmission_password">Password</label>
            <input type="password" name="transmission_password" id="transmission_password"
                   value="{{ config.get('transmission_password', '') }}">

            <h3 style="margin: 1.5rem 0 1rem; font-size: 1rem;">Deluge Settings</h3>

            <label for="deluge_host">Host</label>
            <input type="text" name="deluge_host" id="deluge_host"
                   value="{{ config.get('deluge_host', 'localhost') }}">

            <label for="deluge_port">Port</label>
            <input type="number" name="deluge_port" id="deluge_port"
                   value="{{ config.get('deluge_port', 58846) }}">

            <label for="deluge_username">Username</label>
            <input type="text" name="deluge_username" id="deluge_username"
                   value="{{ config.get('deluge_username', 'localclient') }}">

            <label for="deluge_password">Password</label>
            <input type="password" name="deluge_password" id="deluge_password"
                   value="{{ config.get('deluge_password', 'deluge') }}">

            <h3 style="margin: 1.5rem 0 1rem; font-size: 1rem;">rTorrent Settings</h3>

            <label for="rtorrent_url">XML-RPC URL</label>
            <input type="text" name="rtorrent_url" id="rtorrent_url"
                   value="{{ config.get('rtorrent_url', '') }}"
                   placeholder="http://localhost:8000/RPC2">

            <h3 style="margin: 1.5rem 0 1rem; font-size: 1rem;">aria2 Settings</h3>

            <label for="aria2_host">Host</label>
            <input type="text" name="aria2_host" id="aria2_host"
                   value="{{ config.get('aria2_host', 'localhost') }}">

            <label for="aria2_port">Port</label>
            <input type="number" name="aria2_port" id="aria2_port"
                   value="{{ config.get('aria2_port', 6800) }}">

            <label for="aria2_secret">Secret Token</label>
            <input type="password" name="aria2_secret" id="aria2_secret"
                   value="{{ config.get('aria2_secret', '') }}">

            <button type="button" class="secondary" id="test-torrent" style="margin-top: 0.5rem;">
                Test Connection
            </button>
            <div id="torrent-result" style="margin-top: 0.5rem; font-size: 0.875rem;"></div>
        </div>

        <div class="card">
            <h2>LLM Provider</h2>

            <label for="llm_provider">Provider</label>
            <select name="llm_provider" id="llm_provider">
                <option value="claude_code" {% if config.get('llm_provider', 'claude_code') == 'claude_code' %}selected{% endif %}>Claude Code (Max subscription)</option>
                <option value="anthropic" {% if config.get('llm_provider') == 'anthropic' %}selected{% endif %}>Anthropic API</option>
                <option value="openai" {% if config.get('llm_provider') == 'openai' %}selected{% endif %}>OpenAI</option>
                <option value="ollama" {% if config.get('llm_provider') == 'ollama' %}selected{% endif %}>Ollama (local)</option>
                <option value="google" {% if config.get('llm_provider') == 'google' %}selected{% endif %}>Google Gemini</option>
                <option value="openrouter" {% if config.get('llm_provider') == 'openrouter' %}selected{% endif %}>OpenRouter</option>
            </select>

            <label for="llm_model">Model</label>
            <input type="text" name="llm_model" id="llm_model" list="model-list"
                   value="{{ config.get('llm_model', 'sonnet') }}"
                   placeholder="sonnet, opus, gpt-4o, llama3.2, etc.">
            <datalist id="model-list"></datalist>

            <button type="button" class="secondary" id="test-llm" style="margin-top: 0.5rem;">
                Test Connection
            </button>
            <div id="llm-result" style="margin-top: 0.5rem; font-size: 0.875rem;"></div>

            <h2 style="margin-top: 1.5rem;">Browser</h2>

            <label for="browser_mode">Browser Mode</label>
            <select name="browser_mode" id="browser_mode">
                <option value="chrome" {% if config.get('browser_mode', 'chrome') == 'chrome' %}selected{% endif %}>Claude Chrome Integration</option>
                <option value="browser_use" {% if config.get('browser_mode') == 'browser_use' %}selected{% endif %}>browser-use (Playwright)</option>
            </select>

            <label for="browser_use_mcp_command">browser-use MCP Command</label>
            <input type="text" name="browser_use_mcp_command" id="browser_use_mcp_command"
                   value="{{ config.get('browser_use_mcp_command', 'uvx') }}"
                   placeholder="uvx">

            <label for="browser_use_mcp_args">browser-use MCP Args</label>
            <input type="text" name="browser_use_mcp_args" id="browser_use_mcp_args"
                   value="{{ config.get('browser_use_mcp_args', 'browser-use[mcp]') }}"
                   placeholder="browser-use[mcp]">
            <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.25rem;">
                Used only when Browser Mode is set to browser-use.
            </div>

            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-top: 0.5rem;">
                <input type="checkbox" name="headless" id="headless" style="width: auto;"
                       {% if config.get('headless', true) %}checked{% endif %}>
                <span>Headless mode (use Xvfb for Chrome)</span>
            </label>

            <h2 style="margin-top: 1.5rem;">Paths</h2>

            <label for="download_dir">Download Directory</label>
            <input type="text" name="download_dir" id="download_dir"
                   value="{{ config.get('download_dir', './downloads') }}">

            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" name="download_allow_insecure" id="download_allow_insecure" style="width: auto;"
                       {% if config.get('download_allow_insecure', true) %}checked{% endif %}>
                <span>Allow insecure downloads (skip TLS verification)</span>
            </label>

            <div class="grid-2">
                <div>
                    <label for="download_retry_attempts">Download Retry Attempts</label>
                    <input type="number" name="download_retry_attempts" id="download_retry_attempts"
                           min="1" max="10" value="{{ config.get('download_retry_attempts', 2) }}">
                </div>
                <div>
                    <label for="download_retry_backoff_sec">Retry Backoff (seconds)</label>
                    <input type="number" name="download_retry_backoff_sec" id="download_retry_backoff_sec"
                           step="0.5" min="0" value="{{ config.get('download_retry_backoff_sec', 2.0) }}">
                </div>
            </div>

            <label for="download_max_parallel">Max Parallel Downloads</label>
            <input type="number" name="download_max_parallel" id="download_max_parallel"
                   min="1" max="32" value="{{ config.get('download_max_parallel', 4) }}">

            <label for="path_mappings">Path Mappings (one per line, host:container)</label>
            <textarea name="path_mappings" id="path_mappings" rows="4"
                      placeholder="/mnt/downloads:/downloads">{{ config.get('path_mappings', []) | join('\n') }}</textarea>

            <h2 style="margin-top: 1.5rem;">Logging</h2>

            <label for="log_level">Log Level</label>
            <select name="log_level" id="log_level">
                <option value="DEBUG" {% if config.get('log_level') == 'DEBUG' %}selected{% endif %}>Debug</option>
                <option value="INFO" {% if config.get('log_level', 'INFO') == 'INFO' %}selected{% endif %}>Info</option>
                <option value="WARNING" {% if config.get('log_level') == 'WARNING' %}selected{% endif %}>Warning</option>
                <option value="ERROR" {% if config.get('log_level') == 'ERROR' %}selected{% endif %}>Error</option>
            </select>
        </div>
    </div>

    <div class="card">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <span style="color: var(--text-dim);">Config file: </span>
                <code>{{ config_path }}</code>
            </div>
            <button type="submit">Save Configuration</button>
        </div>
    </div>
</form>

{% endblock %}

{% block scripts %}
<script>
async function testConnection(endpoint, resultId, buttonId, formData) {
    const btn = document.getElementById(buttonId);
    const result = document.getElementById(resultId);

    btn.disabled = true;
    btn.textContent = 'Testing...';
    result.innerHTML = '<span style="color: var(--text-dim);">Testing connection...</span>';

    try {
        const resp = await fetch(endpoint, {
            method: 'POST',
            body: formData
        });
        const data = await resp.json();

        if (data.success) {
            result.innerHTML = `<span style="color: var(--success);">✓ ${data.message}</span>`;
        } else {
            result.innerHTML = `<span style="color: var(--error);">✗ ${data.error}</span>`;
        }
    } catch (e) {
        result.innerHTML = `<span style="color: var(--error);">✗ ${e.message}</span>`;
    } finally {
        btn.disabled = false;
        btn.textContent = 'Test Connection';
    }
}

document.getElementById('test-torrent').addEventListener('click', () => {
    const form = document.querySelector('form');
    const formData = new FormData(form);
    testConnection('/api/test/torrent', 'torrent-result', 'test-torrent', formData);
});

document.getElementById('test-llm').addEventListener('click', () => {
    const form = document.querySelector('form');
    const formData = new FormData(form);
    testConnection('/api/test/llm', 'llm-result', 'test-llm', formData);
});

// Model autocomplete based on provider
const staticModelLists = {
    openai: ['gpt-4o', 'gpt-4o-mini', 'gpt-4-turbo', 'o1', 'o1-mini', 'o3-mini'],
    google: ['gemini-2.0-flash', 'gemini-1.5-pro', 'gemini-1.5-flash'],
    openrouter: ['anthropic/claude-3.5-sonnet', 'openai/gpt-4o', 'google/gemini-pro'],
};

function updateModelList(provider) {
    const datalist = document.getElementById('model-list');
    datalist.innerHTML = '';

    // Static lists for some providers
    if (staticModelLists[provider]) {
        staticModelLists[provider].forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            datalist.appendChild(option);
        });
        return;
    }

    // Fetch dynamically for Ollama
    if (provider === 'ollama') {
        fetch('/api/ollama/models')
            .then(r => r.json())
            .then(data => {
                if (data.models) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        datalist.appendChild(option);
                    });
                }
            })
            .catch(() => {});
        return;
    }

    // Fetch dynamically for Claude (claude_code and anthropic)
    if (provider === 'claude_code' || provider === 'anthropic') {
        fetch('/api/claude/models')
            .then(r => r.json())
            .then(data => {
                if (data.models) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        datalist.appendChild(option);
                    });
                }
            })
            .catch(() => {});
    }
}

// Update on provider change
document.getElementById('llm_provider').addEventListener('change', (e) => {
    updateModelList(e.target.value);
});

// Initial load
updateModelList(document.getElementById('llm_provider').value);
</script>
{% endblock %}
